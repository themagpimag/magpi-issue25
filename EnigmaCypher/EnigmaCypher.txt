The Pocket Enigma Cypher Machine is a superbly designed toy that tries to demonstrate the principles of the Enigma cypher as found on the cover of this Issue.  The Enigma Cypher machine was used during World War two by the German armed forces, to send secrete messages to submarines and solders.  I obtained my Pocket version from Bletchley Park [ http://www.bletchleypark.org.uk/ ], but unfortunately it no longer appears to be on sale.  It is made only of plastic and cardboard and is substantially simpler when compared with a real Enigma cypher machine!  On the other hand, if you enjoy encryption and cyphers you will get a kick out of the Pocket Enigma.  It is not too difficult to understand either.   

The Pocket Enigma Cypher Machine is not even close to an unbreakable cypher – it is a trivial cypher to break but it is fun.  Therefore, do not use it to encrypt sensitive information.  A full review of the Pocket Enigma machine, including a detailed description and further reading, can be found at:
 http://www.savory.de/pocket_enigma.html

How does it work?

Each plaintext character is replaced with another character called the cypher text character.  The cypher text character is chosen according to the connection between characters printed on the wheel, where there are two wheels to choose from.

In more detail, the algorithm follows:
1. Cypher wheel (1 or 2) is chosen.  
2. The key character is chosen.
3. The start character is chosen.
4. The wheel is set to the key character and the start character is encoded.
5. The wheel is moved to the start character and the first message character is encoded.
6. The wheel is incremented by 1 position, and the next message character is encoded.
7. Repeat step 6 until the entire message is encoded.
8. The encoded message is arranged such that the encoded start character is separated from encoded message.  (The encoded message is arranged in blocks of, typically, five characters.)

For the message to be successfully decoded by the person that receives the message, they must be given the number of the wheel that was used to encrypt the message and the key character that was chosen.

Now for the limitations:
1. Only upper case characters can be encoded.
2. No punctuation can be encoded, apart from full-stops which are traditionally substituted with X.

With a bit of imagination the encoding algorithm can easily be modified.  For example, more wheels could be used, or the increment could be varied or even reversed.

Python Pocket Enigma

Use a text editor such as nano or emacs to create a new Python file called Py-Enigma.py.  Then add:

 #!/usr/bin/python
 import random
 VERSION = "v1.0.0"
 BUILDDATE = "01/06/2014"

 # Global variables with starting values
 wheel = 1
 pointer_l = 'D'
 pointer_n = ord(pointer_l)-65
 code_start_l = 'J'
 code_start_n = ord(code_start_l)-65
 increment = 1
 blocksize = 5
 DEFAULT_MESSAGE = "ATTACK AT DAWN" # And why not? They will never expect it...

to the top of the file.  65 is substracted since the integer value of A is 65.  Therefore, ord('A')-65 is zero.  The wheel setting is used to select which wheel is used, pointer_I is the initial wheel settings and code_start_I is the starting character.

1. Analysis of the wheels

The wheels have no characters on them, just a lot of connections.  One position has an arrow, or pointer, and is taken as the starting position (actually position 0).  Looking at the pictures on the first page of this article, it is clear that he connections simply connect from one position to another.  These connections indicate how one character should be substituted for another.


The first wheel can be summarised using a Python list:

 WHEEL1 = [-1,3,-5,7,-3,2,3,-2,4,-3,-7,6,-4,1,-1,6,3,-6,2,-3,-2,-6,2,5,-2,1]

So if the character at the pointer is ???? it would become ???? or ??? - modulo 26 maths at work!

The second wheel is similar:

 WHEEL2 = [2,2,-2,-2,-8,3,9,5,-3,1,-1,2,-5,-2,2,-9,-2,8,2,2,-2,-2,8,1,-1,-8]

Again if the character at the pointer is ??? with wheel II it would become ??? or ???.  Add these two lines to the end of the Python file.

2. Encrypting or decrypting a character

The algorithm clearly states that the wheel is incremented (moved 1 position clockwise) after each message character is encoded. In simple terms this means that a repeated character in the message does not get encoded to the same character.  Append the code below to the end of the Python file.

 # Encrypt or decrypt a single character
 def transform_char(character, wheel, pointer):
   character = character.upper()  # Ensure that the character is Upper Case.
   if(65 <= ord(character) <= 90):  # Only characters A-Z can be encrypted or decrypted.    
     char_num = ord(character) - 65  # Convert ASCII to alphabetical position of the character.

     # Choose the wheel one or two offset.  Then use the pointer value.
     if (wheel == 1):
       offset = WHEEL1[(char_num - pointer)%26]  # Use mod with 26 to stay within circle
     else:
       offset = WHEEL2[(char_num - pointer)%26]  # Use mod with 26 to stay within circle

     # Convert alphabetical position of the character back to ASCII
     character = chr(65 + (char_num + offset)%26)  # Convert position back to ASCII character
   else:
     character = ''  # Ensure that nothing is returned if the character is not A-Z.
   return character

Getting the wheel to turn is not so difficult, again thanks to modulo 26 maths. Although, technically this function does not perform the turn, it does take the turning into consideration.

char_num = ord(char)-65 #Convert the character from ASCII to a base number, A=0, B=1, etc.
offset = WHEEL1[(char_num ?? pointer)%26] #Use MOD26 maths to turn the wheel.
char = chr(65 + (char_num + offset)%26) #Derive the encoded character.

So if the pointer was pointing to ??? then the pointer value would be 2.

Next, if the character to be encoded was ??? then the character number would be 5, and the calculated offset would be WHEEL1[3] = 7.

Thus the encoded character is 5 + 7 = 12 => ????

3. Encrypting a string

It is likely that a message of more than 1 character will be used. Thus, a way to repeatedly encode a single character and move the wheel is needed. 

 # Encrypt a string
 def encrypt(plaintext):
   pointer = pointer_n  # Set the wheel to the key character.
   cypher = ''
   cypher += transform_char(code_start_l, wheel, pointer)  # Encrypt the Alpha Start character.
   cypher += ' '
   #Set the wheel to the Alpha Start character.
   pointer = code_start_n
   block = 0

   # Encrypt each letter in the plaintext string
   for o_char in plaintext:
     # Substitute '.' with 'X'
     if o_char == '.':
       o_char = 'X'

     # Encrypt this character
     e_char = transform_char(o_char, wheel, pointer)

     # Do something if the character was encrypted ok.
     if len(e_char) > 0:
       block += 1
       if block > blocksize:
         cypher += ' ' # Add a space after a block of blocksize characters.
         block = 1   # Remembering the character that was blocksize+1.
         
       cypher += e_char  # Add the character to the result.
       pointer = (pointer + increment)%26  # Turn the wheel, using mod 26 to return to zero
   return cypher


That sounds like a loop to me:

for o_char in plaintext: #Step through each character in the message
    if o_char == '.':
        o_char = 'X' #Substitute periods for X's. It is what was often done.
    e_char = transform_char(o_char, wheel, pointer) #Encrypt each letter in the plaintext.
    if len(e_char) > 0: #Do something if the character was encrypted ok.
        block += 1 #Increment the block character count
        if block > blocksize: #Add a space after a block of blocksize characters.
            Cypher += ' ' #Add a space to the result.
            block = 1 #Remembering the character that was blocksize+1.
        cypher += e_char #Add the character to the result.
        pointer = (pointer + increment)%26 #Turn the wheel.

Notice the extra code to replace full stops with ???? characters before encoding, and how the output is formed into nice blocks of blocksize.

4. Decrypting a string

 # Decrypt a string
 def decrypt(cypher):
   pointer = pointer_n  # Set the wheel to the key character.

   # Extract and decrypt the Alpha Start character.
   pointer = ord(transform_char(cypher[:1], wheel, pointer))-65

   plaintext = ''

   # Decrypt each letter in the cypher.
   for e_char in cypher[1:]:

     # Decrypt this character
     o_char = transform_char(e_char, wheel, pointer)

     # Do something if the character was decrypted ok.
     if len(o_char) > 0:
       plaintext += o_char   # Add the character to the result.
       pointer = (pointer + increment)%26   # Turn the wheel, using mod 26 to return to zero
   return plaintext

The connection on the wheels are bi-directional. So if a character is encoded as an “F”, then with the wheel in the same position encoding an “F” would return you the original character. Consequently, we can use the same encryption routine to decrypt. We just need a slightly different loop to feed it characters to decrypt.

for e_char in cypher[1:]: #Step through each character in the cypher text
    o_char = transform_char(e_char, wheel, pointer) #Decrypt each letter in the cypher.
    if len(o_char) > 0: #Do something if the character was decrypted ok.
        plaintext += o_char #Add the character to the result.
        pointer = (pointer + increment)%26 #Turn the wheel.

Yes, you will find that a lot is lost in the encryption/decryption process, specifically all spacing and punctuation. It is up to you to put that back, replacing ???? characters that do not make sense with full stops.

5. Adding a menu


FUNCTION  ?? def main():
FUNCTION  ?? def show_menu(min, max, quit):
FUNCTION  ?? def get_choice(min, max, quit):

That is easy to say, but actually accounts for a lot of the Python code. The menu also allows other things to be set, like the wheel number and starting key etc.

First we have to print the menu, then get the User choice, and then perform the action. This section of code ties all that together. Notice that it is basically a big IF statement, dependant upon the User choice ??? restricting the User choice to numbers helps with this:

    while not prg_quit:
        show_menu(menu_min, menu_max, menu_quit) #Show the Menu.
        user_choice = get_choice(menu_min, menu_max, menu_quit) #Get the User Choice.
        #Take action as per selected menu-option.
        if user_choice == menu_quit:
            prg_quit = True
        elif user_choice == 1:
            wheel = prg_choice1()
        elif user_choice == 2:
            pointer_l = prg_choice2()
            pointer_n = ord(pointer_l)-65
        elif user_choice == 3:
            code_start_l = prg_choice3()
            code_start_n = ord(code_start_l )-65
        elif user_choice == 4:
            increment = prg_choice4()
        elif user_choice == 5:
            blocksize = prg_choice5()
        elif user_choice == 6:
            prg_choice6()
        elif user_choice == 7:
            prg_choice7()
        elif user_choice == 8:
            prg_choice6()
        elif user_choice == 9:
            prg_choice7()

Step 6. The Other Functions...
FUNCTION ??? def welcome(message):
FUNCTION ??? def prg_choice1() ??? def prg_choice7:
FUNCTION ??? def prg_choice8() ??? def prg_choice9:

These functions are pretty self explanatory!

So what do we have:
First we have the Menu:
Py-Enigma - The Pocket Enigma Cypher Machine
   Version, v1.0.0 , 05/05/2014

------------------------------
      P y - E N I G M A
      M A I N - M E N U
------------------------------

 1. Set Wheel      = 1
 2. Set Pointer    = D
 3. Set Code Start = J
 4. Set Increment  = 1
 5. Set Block Size = 5
 6. Encrypt a Message
 7. Decrypt a Message

 0. Exit program

------------------------------
Enter choice [1-7]: 

Let encrypt a really important message:
------------------------------
Enter choice [1-7]: 6

Enter Plaintext: ATTACK AT DAWN
Encryption: ATTACK AT DAWN => M UQXZI MGAZE DK
------------------------------
Now we have just received a message, lets decrypt it:
------------------------------
Enter choice [1-7]: 7

Enter Cypher: M UQXZI MGAZE DK
Plaintext: M UQXZI MGAZE DK => ATTACKATDAWN
------------------------------
What next?
Well that depends... let me know what you think. All/any feedback is appreciated.




#MAIN PROGRAM
def main():
    global wheel, pointer_l, pointer_n, code_start_l, code_start_n, increment, blocksize
    welcome("Py-Enigma - The Pocket Enigma Cypher Machine")
    menu_min = 1
    menu_max = 7
    menu_quit = 0
    prg_quit = False
    while not prg_quit:
        #Show the Menu.
        show_menu(menu_min, menu_max, menu_quit)
        #Get the User Choice.
        user_choice = get_choice(menu_min, menu_max, menu_quit)
        #Take action as per selected menu-option.
        if user_choice == menu_quit:
            prg_quit = True
        elif user_choice == 1:
            wheel = prg_choice1()
        elif user_choice == 2:
            pointer_l = prg_choice2()
            pointer_n = ord(pointer_l)-65
        elif user_choice == 3:
            code_start_l = prg_choice3()
            code_start_n = ord(code_start_l )-65
        elif user_choice == 4:
            increment = prg_choice4()
        elif user_choice == 5:
            blocksize = prg_choice5()
        elif user_choice == 6:
            prg_choice6()
        elif user_choice == 7:
            prg_choice7()
        elif user_choice == 8:
            prg_choice6()
        elif user_choice == 9:
            prg_choice7()
    print "\nGoodbye.\n"
    return
    #End

#FUNCTIONS

 # Print a welcome message
 def welcome(message):
   print message
   print "   Version,", str(VERSION), ",", str(BUILDDATE)
   print

 # Show Menu
 def show_menu(min, max, quit):
   print (30 * '-')
   print "      P y - E N I G M A"
   print "      M A I N - M E N U"
   print (30 * '-')
   print
   if (min <= 1 <= max):
     print " 1. Set Wheel      =", wheel
   if (min <= 2 <= max):
     print " 2. Set Pointer    =", pointer_l
   if (min <= 3 <= max):
     print " 3. Set Code Start =", code_start_l
   if (min <= 4 <= max):
     print " 4. Set Increment  =", increment
   if (min <= 5 <= max):
     print " 5. Set Block Size =", blocksize
   if (min <= 6 <= max):
     print " 6. Encrypt a Message"
   if (min <= 7 <= max):
     print " 7. Decrypt a Message"
   if (min <= 8 <= max):
     print " 8. Nothing Yet"
   if (min <= 9 <= max):
     print " 9. Nothing Yet"
   print
   print " " + str(quit) + ". Exit program"
   print
   print (30 * '-')

 #Get User Choice
 def get_choice(min, max, quit):
   #Wait for valid choice in while...not.
   choice_is_valid=False
   while not choice_is_valid:
     try:
       choice = int(raw_input("Enter choice [" + str(min) + "-" + str(max) + "]: "))
       if (min <= choice <= max or choice == quit):
         #A valid choice will terminate the while...not loop.
         choice_is_valid = True
       else:
         print"Error! Only numbers "+str(min)+"-"+str(max)+"or"+str(quit)+" are valid."
     except ValueError as e:
       print("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
   return choice

 #Option 1
 def prg_choice1():
   print
   #Wait for valid choice in while...not.
   choice_is_valid=False
   while not choice_is_valid:
     try:
       choice = int(raw_input("Enter Coding Wheel [1 or 2]: "))
       if (1 <= choice <= 2):
         #A valid choice will terminate the while...not loop.
         choice_is_valid = True
       else:
         print"Error! Only numbers 1 or 2 are valid."
     except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 2
def prg_choice2():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = raw_input("Enter Pointer Position [A to Z]: ").upper()
            if (65 <= ord(choice) <= 90):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only letters A to Z are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 3
def prg_choice3():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = raw_input("Enter Coding Start Position [A to Z]: ").upper()
            if (65 <= ord(choice) <= 90):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only letters A to Z are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 4
def prg_choice4():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = int(raw_input("Enter Increment [-1, 0 or 1]: "))
            if (-1 <= choice <= 1):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only numbers -1, 0 and 1 are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 5
def prg_choice5():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = int(raw_input("Enter Block Size [1 to 10]: "))
            if (1 <= choice <= 10):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only numbers 1 to 10 are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 6
def prg_choice6():
    print
    plaintext = raw_input("Enter Plaintext: ")
    print "Encryption:", plaintext, "=>", encrypt(plaintext)
    print
    return

#Option 7
def prg_choice7():
    print
    cypher = raw_input("Enter Cypher: ")
    print "Plaintext:", cypher, "=>", decrypt(cypher)
    print
    return

 if __name__ == '__main__':
   main()  #Run the program if it is the primary module