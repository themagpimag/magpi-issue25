What is the Pocket Enigma Cypher Machine?

Quite simply, it is a toy - a superbly designed toy that tries to demonstrate the principles of the Enigma cypher as used during WW2 by the German armed forces. I obtained mine from Bletchley Park, but unfortunately it no longer seems to be available to buy.  Of-course, as it is made only of plastic and cardboard, it is substantially simpler, when compared to a real Enigma cypher machine! On the other hand, if you enjoy codes and cyphers you will get a kick out of this, and it is not too difficult to understand.

Warning: The Pocket Enigma Cypher Machine is not even close to an unbreakable cypher â€“ it is a trivial cypher to break but it is fun.

I would encourage you to visit http://www.savory.de/pocket_enigma.html for a full review of the Pocket Enigma, including a detailed description, a cryptanalysis and further reading.


How does it work?

At a very basic level, each plaintext character is substituted for another character, the cypher text character, according to the connection printed on the chosen wheel.












The encoding algorithm, in more detail:
1. The cypher wheel (I or II) is chosen. This must be pre-shared with the message recipient.
2. The Key character is chosen. This must be pre-shared with the message recipient.
3. The start character is chosen.
4. The wheel is set to the Key character and the start character is encoded.
5. The wheel is moved to the start character and the first message character is encoded.
6. The wheel is incremented by 1 position, and the next message character is encoded.
7. Repeat step 6 until the entire message is encoded.
8. The encoded message is arranged with the encoded start character separated from encoded message which is arranged in blocks of, typically, 5 characters.

Now for the limitations:
1. Only upper case characters can be encoded.
2. No punctuation can be encoded, apart from full-stops which are traditionally substituted with ???

With a bit of imagination the encoding algorithm can easily be modified. For example, more wheels could be used, or the increment could be varied or even reversed.

Implementing the Pocket Enigma in Python

What do I want to achieve? At this stage a text interface allowing me to set up the wheel and key and then encrypt and decrypt messages would be nice. Perhaps, later, a GUI could be created.

Step 1. Analysis of those Wheels.
The wheels have no characters on them, just a lot of connections. One position has an arrow, or pointer, and is taken as the starting position (actually position 0). It can be seen that the connections simply connect from one position to another, thus substituting, or encoding, one character as another and is symmetrical.

Wheel I can be summarised:

WHEEL1 = [-1,3,-5,7,-3,2,3,-2,4,-3,-7,6,-4,1,-1,6,3,-6,2,-3,-2,-6,2,5,-2,1]

So if the character at the pointer is ???? it would become ???? or ??? - modulo 26 maths at work!

Similarly for Wheel II:

WHEEL2 = [2,2,-2,-2,-8,3,9,5,-3,1,-1,2,-5,-2,2,-9,-2,8,2,2,-2,-2,8,1,-1,-8]

Again if the character at the pointer is ??? with wheel II it would become ??? or ???

Step 2. Those Wheels move!
FUNCTION ???? def transform_char(char, wheel, pointer):

The algorithm clearly states that the wheel is incremented (moved 1 position clockwise) after each message character is encoded. In simple terms this means that a repeated character in the message does not get encoded to the same character.

Getting the wheel to turn is not so difficult, again thanks to modulo 26 maths. Although, technically this function does not perform the turn, it does take the turning into consideration.

char_num = ord(char)-65 #Convert the character from ASCII to a base number, A=0, B=1, etc.
offset = WHEEL1[(char_num â?? pointer)%26] #Use MOD26 maths to turn the wheel.
char = chr(65 + (char_num + offset)%26) #Derive the encoded character.

So if the pointer was pointing to ??? then the pointer value would be 2.

Next, if the character to be encoded was ??? then the character number would be 5, and the calculated offset would be WHEEL1[3] = 7.

Thus the encoded character is 5 + 7 = 12 => ????

Step 3. More than 1 Character Please.
FUNCTION ???? def encrypt(plaintext):

It is likely that a message of more than 1 character will be used. Thus, a way to repeatedly encode a single character and move the wheel is needed. That sounds like a loop to me:

for o_char in plaintext: #Step through each character in the message
    if o_char == '.':
        o_char = 'X' #Substitute periods for X's. It is what was often done.
    e_char = transform_char(o_char, wheel, pointer) #Encrypt each letter in the plaintext.
    if len(e_char) > 0: #Do something if the character was encrypted ok.
        block += 1 #Increment the block character count
        if block > blocksize: #Add a space after a block of blocksize characters.
            Cypher += ' ' #Add a space to the result.
            block = 1 #Remembering the character that was blocksize+1.
        cypher += e_char #Add the character to the result.
        pointer = (pointer + increment)%26 #Turn the wheel.

Notice the extra code to replace full stops with ???? characters before encoding, and how the output is formed into nice blocks of blocksize.

Step 4. Now Reverse. Can we Decrypt Too?
FUNCTION â€“ def decrypt(cypher):

The connection on the wheels are bi-directional. So if a character is encoded as an â€œFâ€, then with the wheel in the same position encoding an â€œFâ€ would return you the original character. Consequently, we can use the same encryption routine to decrypt. We just need a slightly different loop to feed it characters to decrypt.

for e_char in cypher[1:]: #Step through each character in the cypher text
    o_char = transform_char(e_char, wheel, pointer) #Decrypt each letter in the cypher.
    if len(o_char) > 0: #Do something if the character was decrypted ok.
        plaintext += o_char #Add the character to the result.
        pointer = (pointer + increment)%26 #Turn the wheel.

Yes, you will find that a lot is lost in the encryption/decryption process, specifically all spacing and punctuation. It is up to you to put that back, replacing ???? characters that do not make sense with full stops.

Step 5. What about a Menu to wrap it all up.
FUNCTION â ?? def main():
FUNCTION â ?? def show_menu(min, max, quit):
FUNCTION â ?? def get_choice(min, max, quit):

That is easy to say, but actually accounts for a lot of the Python code. The menu also allows other things to be set, like the wheel number and starting key etc.

First we have to print the menu, then get the User choice, and then perform the action. This section of code ties all that together. Notice that it is basically a big IF statement, dependant upon the User choice ??? restricting the User choice to numbers helps with this:

    while not prg_quit:
        show_menu(menu_min, menu_max, menu_quit) #Show the Menu.
        user_choice = get_choice(menu_min, menu_max, menu_quit) #Get the User Choice.
        #Take action as per selected menu-option.
        if user_choice == menu_quit:
            prg_quit = True
        elif user_choice == 1:
            wheel = prg_choice1()
        elif user_choice == 2:
            pointer_l = prg_choice2()
            pointer_n = ord(pointer_l)-65
        elif user_choice == 3:
            code_start_l = prg_choice3()
            code_start_n = ord(code_start_l )-65
        elif user_choice == 4:
            increment = prg_choice4()
        elif user_choice == 5:
            blocksize = prg_choice5()
        elif user_choice == 6:
            prg_choice6()
        elif user_choice == 7:
            prg_choice7()
        elif user_choice == 8:
            prg_choice6()
        elif user_choice == 9:
            prg_choice7()

Step 6. The Other Functions...
FUNCTION ??? def welcome(message):
FUNCTION ??? def prg_choice1() ??? def prg_choice7:
FUNCTION ??? def prg_choice8() ??? def prg_choice9:

These functions are pretty self explanatory!

So what do we have:
First we have the Menu:
Py-Enigma - The Pocket Enigma Cypher Machine
   Version, v1.0.0 , 05/05/2014

------------------------------
      P y - E N I G M A
      M A I N - M E N U
------------------------------

 1. Set Wheel      = 1
 2. Set Pointer    = D
 3. Set Code Start = J
 4. Set Increment  = 1
 5. Set Block Size = 5
 6. Encrypt a Message
 7. Decrypt a Message

 0. Exit program

------------------------------
Enter choice [1-7]: 

Let encrypt a really important message:
------------------------------
Enter choice [1-7]: 6

Enter Plaintext: ATTACK AT DAWN
Encryption: ATTACK AT DAWN => M UQXZI MGAZE DK

------------------------------

Now we have just received a message, lets decrypt it:
------------------------------
Enter choice [1-7]: 7

Enter Cypher: M UQXZI MGAZE DK
Plaintext: M UQXZI MGAZE DK => ATTACKATDAWN

------------------------------

What next?

Well that depends... let me know what you think. All/any feedback is appreciated.







#!/usr/bin/python
#Filename: Py-Enigma.py

#A Python implementation of the Pocket Enigma Cypher Machine.

#Ian Neill (c)2014
# - Works with Python v2.7

import random

VERSION = "v1.0.0"
BUILDDATE = "01/06/2014"

#WHEEL DEFINITIONS
WHEEL1 = [-1,3,-5,7,-3,2,3,-2,4,-3,-7,6,-4,1,-1,6,3,-6,2,-3,-2,-6,2,5,-2,1]
WHEEL2 = [2,2,-2,-2,-8,3,9,5,-3,1,-1,2,-5,-2,2,-9,-2,8,2,2,-2,-2,8,1,-1,-8]

#GLOBAL VARIABLES WITH STARTING VALUES
wheel = 1
pointer_l = 'D'
pointer_n = ord(pointer_l)-65
code_start_l = 'J'
code_start_n = ord(code_start_l)-65
increment = 1
blocksize = 5

DEFAULT_MESSAGE = "ATTACK AT DAWN" #And why not? They will never expect it...

#MAIN PROGRAM
def main():
    global wheel, pointer_l, pointer_n, code_start_l, code_start_n, increment, blocksize
    welcome("Py-Enigma - The Pocket Enigma Cypher Machine")
    menu_min = 1
    menu_max = 7
    menu_quit = 0
    prg_quit = False
    while not prg_quit:
        #Show the Menu.
        show_menu(menu_min, menu_max, menu_quit)
        #Get the User Choice.
        user_choice = get_choice(menu_min, menu_max, menu_quit)
        #Take action as per selected menu-option.
        if user_choice == menu_quit:
            prg_quit = True
        elif user_choice == 1:
            wheel = prg_choice1()
        elif user_choice == 2:
            pointer_l = prg_choice2()
            pointer_n = ord(pointer_l)-65
        elif user_choice == 3:
            code_start_l = prg_choice3()
            code_start_n = ord(code_start_l )-65
        elif user_choice == 4:
            increment = prg_choice4()
        elif user_choice == 5:
            blocksize = prg_choice5()
        elif user_choice == 6:
            prg_choice6()
        elif user_choice == 7:
            prg_choice7()
        elif user_choice == 8:
            prg_choice6()
        elif user_choice == 9:
            prg_choice7()
    print "\nGoodbye.\n"
    return
    #End

#FUNCTIONS

#Welcome Function
def welcome(message):
    print message
    print "   Version,", str(VERSION), ",", str(BUILDDATE)
    print
    return

#Show Menu
def show_menu(min, max, quit):
    print (30 * '-')
    print "      P y - E N I G M A"
    print "      M A I N - M E N U"
    print (30 * '-')
    print
    if (min <= 1 <= max):
        print " 1. Set Wheel      =", wheel
    if (min <= 2 <= max):
        print " 2. Set Pointer    =", pointer_l
    if (min <= 3 <= max):
        print " 3. Set Code Start =", code_start_l
    if (min <= 4 <= max):
        print " 4. Set Increment  =", increment
    if (min <= 5 <= max):
        print " 5. Set Block Size =", blocksize
    if (min <= 6 <= max):
        print " 6. Encrypt a Message"
    if (min <= 7 <= max):
        print " 7. Decrypt a Message"
    if (min <= 8 <= max):
        print " 8. Nothing Yet"
    if (min <= 9 <= max):
        print " 9. Nothing Yet"
    print
    print " " + str(quit) + ". Exit program"
    print
    print (30 * '-')
    return

#Get User Choice
def get_choice(min, max, quit):
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = int(raw_input("Enter choice [" + str(min) + "-" + str(max) + "]: "))
            if (min <= choice <= max or choice == quit):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only numbers " + str(min) + "-" + str(max) + " or " + str(quit) + " are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    return(choice)

#Option 1
def prg_choice1():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = int(raw_input("Enter Coding Wheel [1 or 2]: "))
            if (1 <= choice <= 2):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only numbers 1 or 2 are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 2
def prg_choice2():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = raw_input("Enter Pointer Position [A to Z]: ").upper()
            if (65 <= ord(choice) <= 90):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only letters A to Z are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 3
def prg_choice3():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = raw_input("Enter Coding Start Position [A to Z]: ").upper()
            if (65 <= ord(choice) <= 90):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only letters A to Z are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 4
def prg_choice4():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = int(raw_input("Enter Increment [-1, 0 or 1]: "))
            if (-1 <= choice <= 1):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only numbers -1, 0 and 1 are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 5
def prg_choice5():
    print
    #Wait for valid choice in while...not.
    choice_is_valid=False
    while not choice_is_valid:
        try:
            choice = int(raw_input("Enter Block Size [1 to 10]: "))
            if (1 <= choice <= 10):
                #A valid choice will terminate the while...not loop.
                choice_is_valid = True
            else:
                print"Error! Only numbers 1 to 10 are valid."
        except ValueError as e:
            print ("Error! %s is not a valid choice." % e.args[0].split(": ")[1])
    print
    return(choice)

#Option 6
def prg_choice6():
    print
    plaintext = raw_input("Enter Plaintext: ")
    print "Encryption:", plaintext, "=>", encrypt(plaintext)
    print
    return

#Option 7
def prg_choice7():
    print
    cypher = raw_input("Enter Cypher: ")
    print "Plaintext:", cypher, "=>", decrypt(cypher)
    print
    return

#Option 8
def prg_choice8():
    return

#Option 9
def prg_choice9():
    return

#Encrypt a string
def encrypt(plaintext):
    #Set the wheel to the key character.
    pointer = pointer_n
    cypher = ''
    #Encrypt the Alpha Start character.
    cypher += transform_char(code_start_l, wheel, pointer)
    cypher += ' '
    #Set the wheel to the Alpha Start character.
    pointer = code_start_n
    block = 0
    for o_char in plaintext:
        #Substitute periods with X's.
        if o_char == '.':
            o_char = 'X'
        #Encrypt each letter in the plaintext.
        e_char = transform_char(o_char, wheel, pointer)
        #Do something if the character was encrypted ok.
        if len(e_char) > 0:
            block += 1
            #Add a space after a block of blocksize characters.
            if block > blocksize:
                cypher += ' '
                block = 1 #Remembering the character that was blocksize+1.
            #Add the character to the result.
            cypher += e_char
            #Turn the wheel.
            pointer = (pointer + increment)%26
    return(cypher)

#Decrypt a string
def decrypt(cypher):
    #Set the wheel to the key character.
    pointer = pointer_n
    #Extract and decrypt the Alpha Start character.
    pointer = ord(transform_char(cypher[:1], wheel, pointer))-65
    plaintext = ''
    for e_char in cypher[1:]:
        #Decrypt each letter in the cypher.
        o_char = transform_char(e_char, wheel, pointer)
        #Do something if the character was decrypted ok.
        if len(o_char) > 0:
            #Add the character to the result.
            plaintext += o_char
            #Turn the wheel.
            pointer = (pointer + increment)%26
    return(plaintext)

#Encrypt/Decrypt a single character
def transform_char(char, wheel, pointer):
    
    char = char.upper()  # Ensure that the character is Upper Case.
    #Only characters A-Z can be encrypted or decrypted.
    if(65 <= ord(char) <= 90):
        #ASCII => Alphabetical position of the character.
        char_num = ord(char)-65
        if (wheel == 1):
            #Get the Wheel1 Offset for this character with this pointer.
            #Uses MOD maths to turn the Wheel1 List into a circle.
            offset = WHEEL1[(char_num - pointer)%26]
        else:
            #Get the Wheel2 Offset for this character with this pointer.
            #Uses MOD maths to turn the Wheel2 List into a circle.
            offset = WHEEL2[(char_num - pointer)%26]
        #Transformed alphabetical position of the character => ASCII.
        #Uses MOD maths to turn the alphabet into a circle.
        char = chr(65 + (char_num + offset)%26)
    else:
        #Ensure nothing is returned if the character is not A-Z.
        char = ''
    return(char)

 if __name__ == '__main__':
   main()  #Run the program if it is the primary module